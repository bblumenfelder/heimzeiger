<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HeimZeiger - Zuf√§llige Namensauswahl</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .pointer-bounce {
            animation: bounce 0.3s ease-in-out infinite alternate;
        }
        
        @keyframes bounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        .name-list {
            transition: transform 0.1s ease-out;
        }
        
        .name-list.scrolling {
            transition: transform 0.05s linear;
        }
        
        .name-item {
            transition: all 0.3s ease;
        }
        
        .name-item.highlighted {
            background: linear-gradient(135deg, #ec4899, #10b981);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(236, 72, 153, 0.4);
        }
        
        .selected-name {
            animation: pulse 0.8s ease-in-out infinite alternate;
        }
        
        .winner-pointer {
            animation: celebratePulse 0.6s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            0% { transform: scale(1.05); }
            100% { transform: scale(1.1); }
        }
        
        @keyframes celebratePulse {
            0% { 
                transform: scale(1) rotate(-2deg);
                filter: drop-shadow(0 15px 30px rgba(236, 72, 153, 0.6)) hue-rotate(0deg);
            }
            50% { 
                transform: scale(1.15) rotate(1deg);
                filter: drop-shadow(0 25px 50px rgba(16, 185, 129, 0.6)) hue-rotate(120deg);
            }
            100% { 
                transform: scale(1.3) rotate(-1deg);
                filter: drop-shadow(0 35px 70px rgba(236, 72, 153, 0.8)) hue-rotate(240deg);
            }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        .winner-celebration {
            animation: winnerBounce 0.8s ease-out;
        }
        
        @keyframes winnerBounce {
            0% { 
                transform: scale(0.3) rotate(-10deg);
                opacity: 0;
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                opacity: 1;
            }
            70% { 
                transform: scale(0.95) rotate(-2deg);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        /* KONFETTI ANIMATION */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s linear infinite;
        }
        
        .confetti:nth-child(odd) {
            background: linear-gradient(45deg, #ec4899, #f97316);
            border-radius: 50%;
        }
        
        .confetti:nth-child(even) {
            background: linear-gradient(45deg, #10b981, #06b6d4);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }
        
        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotateZ(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotateZ(720deg);
                opacity: 0;
            }
        }
        
        .confetti:nth-child(1) { left: 10%; animation-delay: 0s; animation-duration: 3s; }
        .confetti:nth-child(2) { left: 20%; animation-delay: 0.5s; animation-duration: 3.5s; }
        .confetti:nth-child(3) { left: 30%; animation-delay: 1s; animation-duration: 2.5s; }
        .confetti:nth-child(4) { left: 40%; animation-delay: 0.3s; animation-duration: 3.2s; }
        .confetti:nth-child(5) { left: 50%; animation-delay: 0.8s; animation-duration: 2.8s; }
        .confetti:nth-child(6) { left: 60%; animation-delay: 0.2s; animation-duration: 3.1s; }
        .confetti:nth-child(7) { left: 70%; animation-delay: 0.6s; animation-duration: 2.9s; }
        .confetti:nth-child(8) { left: 80%; animation-delay: 0.9s; animation-duration: 3.3s; }
        .confetti:nth-child(9) { left: 90%; animation-delay: 0.4s; animation-duration: 2.7s; }
        .confetti:nth-child(10) { left: 15%; animation-delay: 0.7s; animation-duration: 3.4s; }
        .confetti:nth-child(11) { left: 25%; animation-delay: 1.2s; animation-duration: 2.6s; }
        .confetti:nth-child(12) { left: 35%; animation-delay: 0.1s; animation-duration: 3.6s; }
        .confetti:nth-child(13) { left: 45%; animation-delay: 0.9s; animation-duration: 2.4s; }
        .confetti:nth-child(14) { left: 55%; animation-delay: 0.3s; animation-duration: 3.7s; }
        .confetti:nth-child(15) { left: 65%; animation-delay: 0.6s; animation-duration: 2.3s; }
        .confetti:nth-child(16) { left: 75%; animation-delay: 1.1s; animation-duration: 3.8s; }
        .confetti:nth-child(17) { left: 85%; animation-delay: 0.2s; animation-duration: 2.2s; }
        .confetti:nth-child(18) { left: 95%; animation-delay: 0.8s; animation-duration: 3.9s; }
        .confetti:nth-child(19) { left: 5%; animation-delay: 0.5s; animation-duration: 2.1s; }
        .confetti:nth-child(20) { left: 12%; animation-delay: 1.3s; animation-duration: 4s; }
        
        /* Extra kitschig f√ºr Header */
        .kitsch-title {
            animation: rainbowPulse 2s ease-in-out infinite alternate;
        }
        
                 @keyframes rainbowPulse {
             0% { 
                 transform: scale(1);
                 filter: hue-rotate(0deg);
             }
             50% { 
                 transform: scale(1.05);
                 filter: hue-rotate(180deg);
             }
             100% { 
                 transform: scale(1);
                 filter: hue-rotate(360deg);
             }
         }
         
         .winner-glow {
             animation: winnerGlow 3s ease-in-out infinite;
         }
         
         @keyframes winnerGlow {
             0% { 
                 box-shadow: 0 0 20px rgba(236, 72, 153, 0.3);
             }
             50% { 
                 box-shadow: 0 0 60px rgba(16, 185, 129, 0.6), 0 0 100px rgba(236, 72, 153, 0.4);
             }
             100% { 
                 box-shadow: 0 0 20px rgba(236, 72, 153, 0.3);
             }
         }
    </style>
</head>
<body class="bg-gradient-to-br from-pink-200 via-green-100 to-pink-300 min-h-screen">
    <div id="app" :class="{ 'winner-glow': isFinished }">
        <!-- Konfetti Container -->
        <div v-if="isFinished" class="confetti-container">
            <div class="confetti" v-for="n in 20" :key="n"></div>
        </div>
        
        <!-- Header -->
        <header class="text-center py-8">
            <h1 class="text-4xl font-bold bg-gradient-to-r from-pink-600 to-green-600 bg-clip-text text-transparent mb-2 kitsch-title">üéØ‚ú® HeimZeiger ‚ú®üéØ</h1>
            <p class="text-pink-700 font-semibold text-lg">üíñ Zuf√§llige Namensauswahl mit dem Zeiger üíö</p>
        </header>

        <!-- Main Content -->
        <main class="container mx-auto px-4">
            <div class="flex flex-col lg:flex-row items-start justify-center gap-8 max-w-7xl mx-auto">
                
                <!-- Names List Column -->
                <div class="w-full lg:w-1/3 order-2 lg:order-1">
                    <div class="bg-white rounded-lg shadow-xl overflow-hidden border-4 border-pink-400">
                        <div class="bg-gradient-to-r from-pink-500 to-green-500 text-white p-4 text-center">
                            <h3 class="text-xl font-bold">üíñ Namensliste üíö</h3>
                            <div class="text-sm opacity-90">‚ú® {{ names.length }} Namen ‚ú®</div>
                        </div>
                        
                        <!-- Scrollable Name List -->
                        <div class="h-80 overflow-hidden relative bg-gradient-to-b from-pink-50 to-green-50">
                            <!-- Target indicator where pointer points -->
                            <div class="absolute top-4 left-0 right-0 h-16 bg-gradient-to-r from-pink-300 to-green-300 bg-opacity-20 border-y-2 border-pink-400 z-0 pointer-events-none"></div>
                            
                            <div class="name-list" 
                                 :class="{ 'scrolling': isRunning }"
                                 :style="{ transform: `translateY(${listOffset}px)` }">
                                <div v-for="(name, index) in displayNames" 
                                     :key="`${name}-${index}`"
                                     class="name-item p-4 border-b border-pink-200 text-center font-semibold text-pink-800 hover:bg-green-100"
                                     :class="{ 
                                         'highlighted': index === highlightedIndex && isRunning,
                                         'selected-name': index === highlightedIndex && isFinished 
                                     }">
                                    {{ name }}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pointer Image Column -->
                <div class="w-full lg:w-1/3 order-1 lg:order-2 flex justify-center">
                    <div class="relative">
                        <img src="Zeiger.png" 
                             alt="Zeiger" 
                             class="w-96 h-96 lg:w-[500px] lg:h-[500px] object-contain"
                             :class="{ 
                                 'pointer-bounce': isRunning,
                                 'winner-pointer': isFinished && !isRunning 
                             }"
                             style="filter: drop-shadow(0 10px 20px rgba(0,0,0,0.1));">
                        
                        <!-- Central info when not running -->
                        <div v-if="!isRunning && !isFinished" 
                             class="absolute inset-0 flex items-center justify-center">
                            <div class="bg-gradient-to-r from-pink-100 to-green-100 bg-opacity-95 rounded-full p-6 text-center shadow-xl border-4 border-pink-300 fade-in">
                                <div class="text-xl font-bold bg-gradient-to-r from-pink-600 to-green-600 bg-clip-text text-transparent">
                                    ‚ú® Bereit f√ºr die ‚ú®<br>üíñ Auswahl! üíö
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Results Column -->
                <div class="w-full lg:w-1/3 order-3 lg:order-3 flex justify-center">
                    <div v-if="isFinished" class="bg-gradient-to-r from-pink-200 via-green-200 to-pink-300 border-4 border-pink-500 rounded-lg p-8 shadow-2xl winner-celebration text-center">
                        <div class="text-pink-800 font-bold text-2xl mb-2">
                            üéâüíñ‚ú® GEWINNER! ‚ú®üíöüéâ
                        </div>
                        <div class="text-3xl font-extrabold text-green-900 mt-2 bg-gradient-to-r from-pink-300 to-green-300 rounded-lg p-3 shadow-inner border-2 border-pink-400">
                            {{ selectedName }}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="mt-16 text-center">
                <button @click="startSelection" 
                        :disabled="isRunning"
                        class="bg-gradient-to-r from-pink-500 to-green-500 hover:from-pink-600 hover:to-green-600 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-6 px-12 rounded-full text-2xl shadow-xl transform transition-all duration-200 hover:scale-110 active:scale-95 border-4 border-pink-300"
                        :class="{ 'from-green-500 to-pink-500 hover:from-green-600 hover:to-pink-600 animate-pulse': isFinished }">
                    <span v-if="!isRunning && !isFinished">üéØ‚ú® START ‚ú®üéØ</span>
                    <span v-else-if="isRunning">‚è≥üí´ L√§uft... üí´‚è≥</span>
                    <span v-else>üîÑüíñ Nochmal! üíöüîÑ</span>
                </button>
            </div>


        </main>

        <!-- Footer -->
        <footer class="text-center py-8 mt-12 text-pink-600">
            <p class="font-semibold">üíñ Entwickelt mit Vue.js & Tailwind CSS üíö</p>
        </footer>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    names: [
                        'Elisabeth', 'Philipp', 'Emilia H.', 'Leon', 'Darya',
                        'Mads', 'Tom', 'Lena', 'Lilian', 'Amelie',
                        'Maximilian', 'Michel', 'Clara', 'Ben', 'Leni',
                        'Emilia N.', 'Olivia', 'Victoria', 'Ophelia', 'Helena',
                        'Efe', 'Arndt', 'Emma', 'Alexander', 'Titus',
                        'Sarah', 'Sebastian'
                    ],
                    selectedName: '',
                    isRunning: false,
                    isFinished: false,
                    animationInterval: null,
                    listOffset: 0,
                    highlightedIndex: 0,
                    itemHeight: 65 // height of each name item in pixels
                }
            },
            computed: {
                displayNames() {
                    // Repeat names multiple times for smooth scrolling effect
                    const repeats = 8;
                    const repeated = [];
                    for (let i = 0; i < repeats; i++) {
                        repeated.push(...this.names);
                    }
                    return repeated;
                },
                targetIndex() {
                    // Index of the item that should be in the target zone (1st visible item since target is now top-4)
                    return Math.floor(this.displayNames.length / 2) + 1;
                }
            },
            methods: {
                
                reset() {
                    this.selectedName = '';
                    this.isRunning = false;
                    this.isFinished = false;
                    this.listOffset = 0;
                    this.highlightedIndex = 0;
                    if (this.animationInterval) {
                        cancelAnimationFrame(this.animationInterval);
                        this.animationInterval = null;
                    }
                },
                
                getVisualTargetIndex() {
                    // Alternative Methode: Finde das Element, das visuell im Zielbereich steht
                    // Zielbereich: 16px bis 80px, Mitte bei 48px
                    
                    for (let i = 0; i < this.displayNames.length; i++) {
                        const elementTop = i * this.itemHeight + this.listOffset;
                        const elementBottom = elementTop + this.itemHeight;
                        
                        // Pr√ºfe, ob das Element den Zielbereich (48px ¬± 32px) √ºberlappt
                        if (elementTop <= 48 && elementBottom >= 48) {
                            console.log(`Visuell im Zielbereich: Index ${i}, Name ${this.displayNames[i]}, Top: ${elementTop}, Bottom: ${elementBottom}`);
                            return i;
                        }
                    }
                    
                    // Fallback zur mathematischen Berechnung
                    return this.getTargetZoneIndex();
                },
                
                getTargetZoneIndex() {
                    // Einfache und direkte Berechnung:
                    // Zielbereich ist bei 48px (Mitte zwischen 16px und 80px)
                    // Bei listOffset wird die Liste verschoben
                    // Element an Index i steht bei: i * itemHeight + listOffset
                    // Wir suchen i, sodass: i * itemHeight + listOffset ‚âà 48
                    // Also: i ‚âà (48 - listOffset) / itemHeight
                    
                    const targetIndex = Math.round((48 - this.listOffset) / this.itemHeight);
                    const clampedIndex = Math.max(0, Math.min(targetIndex, this.displayNames.length - 1));
                    
                    console.log(`Zielbereich Berechnung: listOffset=${this.listOffset}, targetIndex=${targetIndex}, clampedIndex=${clampedIndex}, Name=${this.displayNames[clampedIndex]}`);
                    
                    return clampedIndex;
                },
                
                finishAnimation(currentOffset) {
                    console.log(`Finishing animation: currentOffset=${currentOffset}, listOffset=${this.listOffset}`);
                    
                    // Verwende die gleiche visuelle Methode wie in der Animation
                    const finalIndex = this.getVisualTargetIndex();
                    
                    console.log(`Vor Nachjustierung: finalIndex=${finalIndex}, Name=${this.displayNames[finalIndex]}`);
                    
                    // Positioniere das Element exakt in der Mitte des Zielbereichs (48px)
                    // Element an Index i soll bei 48px stehen: i * itemHeight + listOffset = 48
                    // Also: listOffset = 48 - i * itemHeight
                    const newListOffset = 48 - finalIndex * this.itemHeight;
                    this.listOffset = newListOffset;
                    this.highlightedIndex = finalIndex;
                    
                    console.log(`Nach Nachjustierung: newListOffset=${newListOffset}, finalIndex=${finalIndex}`);
                    
                    // Setze den Namen aus dem Zielbereich
                    this.selectedName = this.displayNames[finalIndex];
                    
                    console.log(`Finaler Gewinner: ${this.selectedName}`);
                    
                    // Animation beenden
                    this.isRunning = false;
                    this.isFinished = true;
                    this.playWinnerSound();
                },
                
                playWinnerSound() {
                    // Spiele einen einfachen Ton ab (Browser-kompatibel)
                    try {
                        // Erstelle eine einfache Audiofrequenz
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = 800; // Hohe, fr√∂hliche Frequenz
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    } catch (e) {
                        // Fallback falls Audio nicht funktioniert
                        console.log('üéâ GEWINNER! üéâ');
                    }
                },
                
                startSelection() {
                    // Reset first to ensure clean state
                    this.reset();
                    
                    // Then start the new selection process
                    this.isRunning = true;
                    this.isFinished = false;
                    this.selectedName = '';
                    
                    // Reset list position to start
                    this.listOffset = 0;
                    this.highlightedIndex = 0;
                    
                    // Animation parameters - max 5 seconds
                    let currentOffset = 0;
                    let speed = 15; // Initial speed (pixels per frame)
                    const minDistance = this.names.length * this.itemHeight * 2; // Minimum scroll distance
                    const maxDistance = this.names.length * this.itemHeight * 4; // Maximum scroll distance
                    const randomDistance = minDistance + Math.random() * (maxDistance - minDistance);
                    const maxDuration = 5000; // 5 seconds max
                    const startTime = performance.now();
                    
                    const animate = () => {
                        if (!this.isRunning) return;
                        
                        const elapsed = performance.now() - startTime;
                        
                        // Force stop after max duration
                        if (elapsed >= maxDuration) {
                            this.finishAnimation(currentOffset);
                            return;
                        }
                        
                        // Update position
                        currentOffset += speed;
                        this.listOffset = -currentOffset;
                        
                        // Update highlighted index: Welches Element steht gerade im Zielbereich?
                        this.highlightedIndex = this.getVisualTargetIndex();
                        
                        // Deceleration logic
                        const remaining = randomDistance - currentOffset;
                        const timeRemaining = maxDuration - elapsed;
                        if (remaining < 800 || timeRemaining < 1500) {
                            speed = Math.max(speed * 0.90, 2); // Faster deceleration, higher minimum speed
                        }
                        
                        // Check if we should stop (distance-based)
                        if (currentOffset >= randomDistance) {
                            this.finishAnimation(currentOffset);
                            return;
                        }
                        
                        // Continue animation
                        this.animationInterval = requestAnimationFrame(animate);
                    };
                    
                    // Start animation
                    this.animationInterval = requestAnimationFrame(animate);
                }
            },
            
            beforeUnmount() {
                if (this.animationInterval) {
                    cancelAnimationFrame(this.animationInterval);
                }
            }
        }).mount('#app');
    </script>
</body>
</html> 